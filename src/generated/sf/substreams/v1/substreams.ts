/* eslint-disable */
// @generated by protobuf-ts 2.8.2 with parameter generate_dependencies,long_type_string,eslint_disable,client_generic
// @generated from protobuf file "sf/substreams/v1/substreams.proto" (package "sf.substreams.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Any } from "../../../google/protobuf/any";
import { Clock } from "./clock";
import { Modules } from "./modules";
/**
 * @generated from protobuf message sf.substreams.v1.Request
 */
export interface Request {
    /**
     * @generated from protobuf field: int64 start_block_num = 1;
     */
    startBlockNum: string;
    /**
     * @generated from protobuf field: string start_cursor = 2;
     */
    startCursor: string;
    /**
     * @generated from protobuf field: uint64 stop_block_num = 3;
     */
    stopBlockNum: string;
    /**
     * @generated from protobuf field: repeated sf.substreams.v1.ForkStep fork_steps = 4;
     */
    forkSteps: ForkStep[];
    /**
     * @generated from protobuf field: string irreversibility_condition = 5;
     */
    irreversibilityCondition: string;
    /**
     * @generated from protobuf field: sf.substreams.v1.Modules modules = 6;
     */
    modules?: Modules;
    /**
     * @generated from protobuf field: repeated string output_modules = 7;
     */
    outputModules: string[];
    /**
     * @generated from protobuf field: repeated string initial_store_snapshot_for_modules = 8;
     */
    initialStoreSnapshotForModules: string[];
}
/**
 * @generated from protobuf message sf.substreams.v1.Response
 */
export interface Response {
    /**
     * @generated from protobuf oneof: message
     */
    message: {
        oneofKind: "progress";
        /**
         * @generated from protobuf field: sf.substreams.v1.ModulesProgress progress = 1;
         */
        progress: ModulesProgress; // Progress of data preparation, before sending in the stream of `data` events.
    } | {
        oneofKind: "snapshotData";
        /**
         * @generated from protobuf field: sf.substreams.v1.InitialSnapshotData snapshot_data = 2;
         */
        snapshotData: InitialSnapshotData;
    } | {
        oneofKind: "snapshotComplete";
        /**
         * @generated from protobuf field: sf.substreams.v1.InitialSnapshotComplete snapshot_complete = 3;
         */
        snapshotComplete: InitialSnapshotComplete;
    } | {
        oneofKind: "data";
        /**
         * @generated from protobuf field: sf.substreams.v1.BlockScopedData data = 4;
         */
        data: BlockScopedData;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message sf.substreams.v1.InitialSnapshotComplete
 */
export interface InitialSnapshotComplete {
    /**
     * @generated from protobuf field: string cursor = 1;
     */
    cursor: string;
}
/**
 * @generated from protobuf message sf.substreams.v1.InitialSnapshotData
 */
export interface InitialSnapshotData {
    /**
     * @generated from protobuf field: string module_name = 1;
     */
    moduleName: string;
    /**
     * @generated from protobuf field: sf.substreams.v1.StoreDeltas deltas = 2;
     */
    deltas?: StoreDeltas;
    /**
     * @generated from protobuf field: uint64 sent_keys = 4;
     */
    sentKeys: string;
    /**
     * @generated from protobuf field: uint64 total_keys = 3;
     */
    totalKeys: string;
}
/**
 * @generated from protobuf message sf.substreams.v1.BlockScopedData
 */
export interface BlockScopedData {
    /**
     * @generated from protobuf field: repeated sf.substreams.v1.ModuleOutput outputs = 1;
     */
    outputs: ModuleOutput[];
    /**
     * @generated from protobuf field: sf.substreams.v1.Clock clock = 3;
     */
    clock?: Clock;
    /**
     * @generated from protobuf field: sf.substreams.v1.ForkStep step = 6;
     */
    step: ForkStep;
    /**
     * @generated from protobuf field: string cursor = 10;
     */
    cursor: string;
}
/**
 * @generated from protobuf message sf.substreams.v1.ModuleOutput
 */
export interface ModuleOutput {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "mapOutput";
        /**
         * @generated from protobuf field: google.protobuf.Any map_output = 2;
         */
        mapOutput: Any;
    } | {
        oneofKind: "storeDeltas";
        /**
         * @generated from protobuf field: sf.substreams.v1.StoreDeltas store_deltas = 3;
         */
        storeDeltas: StoreDeltas;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: repeated string logs = 4;
     */
    logs: string[];
    /**
     * LogsTruncated is a flag that tells you if you received all the logs or if they
     * were truncated because you logged too much (fixed limit currently is set to 128 KiB).
     *
     * @generated from protobuf field: bool logs_truncated = 5;
     */
    logsTruncated: boolean;
}
/**
 * @generated from protobuf message sf.substreams.v1.ModulesProgress
 */
export interface ModulesProgress {
    /**
     * @generated from protobuf field: repeated sf.substreams.v1.ModuleProgress modules = 1;
     */
    modules: ModuleProgress[];
}
/**
 * @generated from protobuf message sf.substreams.v1.ModuleProgress
 */
export interface ModuleProgress {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "processedRanges";
        /**
         * @generated from protobuf field: sf.substreams.v1.ModuleProgress.ProcessedRange processed_ranges = 2;
         */
        processedRanges: ModuleProgress_ProcessedRange;
    } | {
        oneofKind: "initialState";
        /**
         * @generated from protobuf field: sf.substreams.v1.ModuleProgress.InitialState initial_state = 3;
         */
        initialState: ModuleProgress_InitialState;
    } | {
        oneofKind: "processedBytes";
        /**
         * @generated from protobuf field: sf.substreams.v1.ModuleProgress.ProcessedBytes processed_bytes = 4;
         */
        processedBytes: ModuleProgress_ProcessedBytes;
    } | {
        oneofKind: "failed";
        /**
         * @generated from protobuf field: sf.substreams.v1.ModuleProgress.Failed failed = 5;
         */
        failed: ModuleProgress_Failed;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message sf.substreams.v1.ModuleProgress.ProcessedRange
 */
export interface ModuleProgress_ProcessedRange {
    /**
     * @generated from protobuf field: repeated sf.substreams.v1.BlockRange processed_ranges = 1;
     */
    processedRanges: BlockRange[];
}
/**
 * @generated from protobuf message sf.substreams.v1.ModuleProgress.InitialState
 */
export interface ModuleProgress_InitialState {
    /**
     * @generated from protobuf field: uint64 available_up_to_block = 2;
     */
    availableUpToBlock: string;
}
/**
 * @generated from protobuf message sf.substreams.v1.ModuleProgress.ProcessedBytes
 */
export interface ModuleProgress_ProcessedBytes {
    /**
     * @generated from protobuf field: uint64 total_bytes_read = 1;
     */
    totalBytesRead: string;
    /**
     * @generated from protobuf field: uint64 total_bytes_written = 2;
     */
    totalBytesWritten: string;
}
/**
 * @generated from protobuf message sf.substreams.v1.ModuleProgress.Failed
 */
export interface ModuleProgress_Failed {
    /**
     * @generated from protobuf field: string reason = 1;
     */
    reason: string;
    /**
     * @generated from protobuf field: repeated string logs = 2;
     */
    logs: string[];
    /**
     * FailureLogsTruncated is a flag that tells you if you received all the logs or if they
     * were truncated because you logged too much (fixed limit currently is set to 128 KiB).
     *
     * @generated from protobuf field: bool logs_truncated = 3;
     */
    logsTruncated: boolean;
}
/**
 * @generated from protobuf message sf.substreams.v1.BlockRange
 */
export interface BlockRange {
    /**
     * @generated from protobuf field: uint64 start_block = 1;
     */
    startBlock: string;
    /**
     * @generated from protobuf field: uint64 end_block = 2;
     */
    endBlock: string;
}
/**
 * @generated from protobuf message sf.substreams.v1.StoreDeltas
 */
export interface StoreDeltas {
    /**
     * @generated from protobuf field: repeated sf.substreams.v1.StoreDelta deltas = 1;
     */
    deltas: StoreDelta[];
}
/**
 * @generated from protobuf message sf.substreams.v1.StoreDelta
 */
export interface StoreDelta {
    /**
     * @generated from protobuf field: sf.substreams.v1.StoreDelta.Operation operation = 1;
     */
    operation: StoreDelta_Operation;
    /**
     * @generated from protobuf field: uint64 ordinal = 2;
     */
    ordinal: string;
    /**
     * @generated from protobuf field: string key = 3;
     */
    key: string;
    /**
     * @generated from protobuf field: bytes old_value = 4;
     */
    oldValue: Uint8Array;
    /**
     * @generated from protobuf field: bytes new_value = 5;
     */
    newValue: Uint8Array;
}
/**
 * @generated from protobuf enum sf.substreams.v1.StoreDelta.Operation
 */
export enum StoreDelta_Operation {
    /**
     * @generated from protobuf enum value: UNSET = 0;
     */
    UNSET = 0,
    /**
     * @generated from protobuf enum value: CREATE = 1;
     */
    CREATE = 1,
    /**
     * @generated from protobuf enum value: UPDATE = 2;
     */
    UPDATE = 2,
    /**
     * @generated from protobuf enum value: DELETE = 3;
     */
    DELETE = 3
}
/**
 * @generated from protobuf message sf.substreams.v1.Output
 */
export interface Output {
    /**
     * @generated from protobuf field: uint64 block_num = 1;
     */
    blockNum: string;
    /**
     * @generated from protobuf field: string block_id = 2;
     */
    blockId: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 4;
     */
    timestamp?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Any value = 10;
     */
    value?: Any;
}
/**
 * @generated from protobuf enum sf.substreams.v1.ForkStep
 */
export enum ForkStep {
    /**
     * @generated from protobuf enum value: STEP_UNKNOWN = 0;
     */
    STEP_UNKNOWN = 0,
    /**
     * Block is new head block of the chain, that is linear with the previous block
     *
     * @generated from protobuf enum value: STEP_NEW = 1;
     */
    STEP_NEW = 1,
    /**
     * Block is now forked and should be undone, it's not the head block of the chain anymore
     *
     * @generated from protobuf enum value: STEP_UNDO = 2;
     */
    STEP_UNDO = 2,
    /**
     * Block is now irreversible and can be committed to (finality is chain specific, see chain documentation for more details)
     *
     * @generated from protobuf enum value: STEP_IRREVERSIBLE = 4;
     */
    STEP_IRREVERSIBLE = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class Request$Type extends MessageType<Request> {
    constructor() {
        super("sf.substreams.v1.Request", [
            { no: 1, name: "start_block_num", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "start_cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "stop_block_num", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "fork_steps", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["sf.substreams.v1.ForkStep", ForkStep] },
            { no: 5, name: "irreversibility_condition", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "modules", kind: "message", T: () => Modules },
            { no: 7, name: "output_modules", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "initial_store_snapshot_for_modules", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Request>): Request {
        const message = { startBlockNum: "0", startCursor: "", stopBlockNum: "0", forkSteps: [], irreversibilityCondition: "", outputModules: [], initialStoreSnapshotForModules: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Request): Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 start_block_num */ 1:
                    message.startBlockNum = reader.int64().toString();
                    break;
                case /* string start_cursor */ 2:
                    message.startCursor = reader.string();
                    break;
                case /* uint64 stop_block_num */ 3:
                    message.stopBlockNum = reader.uint64().toString();
                    break;
                case /* repeated sf.substreams.v1.ForkStep fork_steps */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.forkSteps.push(reader.int32());
                    else
                        message.forkSteps.push(reader.int32());
                    break;
                case /* string irreversibility_condition */ 5:
                    message.irreversibilityCondition = reader.string();
                    break;
                case /* sf.substreams.v1.Modules modules */ 6:
                    message.modules = Modules.internalBinaryRead(reader, reader.uint32(), options, message.modules);
                    break;
                case /* repeated string output_modules */ 7:
                    message.outputModules.push(reader.string());
                    break;
                case /* repeated string initial_store_snapshot_for_modules */ 8:
                    message.initialStoreSnapshotForModules.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 start_block_num = 1; */
        if (message.startBlockNum !== "0")
            writer.tag(1, WireType.Varint).int64(message.startBlockNum);
        /* string start_cursor = 2; */
        if (message.startCursor !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.startCursor);
        /* uint64 stop_block_num = 3; */
        if (message.stopBlockNum !== "0")
            writer.tag(3, WireType.Varint).uint64(message.stopBlockNum);
        /* repeated sf.substreams.v1.ForkStep fork_steps = 4; */
        if (message.forkSteps.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.forkSteps.length; i++)
                writer.int32(message.forkSteps[i]);
            writer.join();
        }
        /* string irreversibility_condition = 5; */
        if (message.irreversibilityCondition !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.irreversibilityCondition);
        /* sf.substreams.v1.Modules modules = 6; */
        if (message.modules)
            Modules.internalBinaryWrite(message.modules, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string output_modules = 7; */
        for (let i = 0; i < message.outputModules.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.outputModules[i]);
        /* repeated string initial_store_snapshot_for_modules = 8; */
        for (let i = 0; i < message.initialStoreSnapshotForModules.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.initialStoreSnapshotForModules[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.Request
 */
export const Request = new Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Response$Type extends MessageType<Response> {
    constructor() {
        super("sf.substreams.v1.Response", [
            { no: 1, name: "progress", kind: "message", oneof: "message", T: () => ModulesProgress },
            { no: 2, name: "snapshot_data", kind: "message", oneof: "message", T: () => InitialSnapshotData },
            { no: 3, name: "snapshot_complete", kind: "message", oneof: "message", T: () => InitialSnapshotComplete },
            { no: 4, name: "data", kind: "message", oneof: "message", T: () => BlockScopedData }
        ]);
    }
    create(value?: PartialMessage<Response>): Response {
        const message = { message: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Response): Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sf.substreams.v1.ModulesProgress progress */ 1:
                    message.message = {
                        oneofKind: "progress",
                        progress: ModulesProgress.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).progress)
                    };
                    break;
                case /* sf.substreams.v1.InitialSnapshotData snapshot_data */ 2:
                    message.message = {
                        oneofKind: "snapshotData",
                        snapshotData: InitialSnapshotData.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).snapshotData)
                    };
                    break;
                case /* sf.substreams.v1.InitialSnapshotComplete snapshot_complete */ 3:
                    message.message = {
                        oneofKind: "snapshotComplete",
                        snapshotComplete: InitialSnapshotComplete.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).snapshotComplete)
                    };
                    break;
                case /* sf.substreams.v1.BlockScopedData data */ 4:
                    message.message = {
                        oneofKind: "data",
                        data: BlockScopedData.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).data)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sf.substreams.v1.ModulesProgress progress = 1; */
        if (message.message.oneofKind === "progress")
            ModulesProgress.internalBinaryWrite(message.message.progress, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sf.substreams.v1.InitialSnapshotData snapshot_data = 2; */
        if (message.message.oneofKind === "snapshotData")
            InitialSnapshotData.internalBinaryWrite(message.message.snapshotData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sf.substreams.v1.InitialSnapshotComplete snapshot_complete = 3; */
        if (message.message.oneofKind === "snapshotComplete")
            InitialSnapshotComplete.internalBinaryWrite(message.message.snapshotComplete, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sf.substreams.v1.BlockScopedData data = 4; */
        if (message.message.oneofKind === "data")
            BlockScopedData.internalBinaryWrite(message.message.data, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.Response
 */
export const Response = new Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitialSnapshotComplete$Type extends MessageType<InitialSnapshotComplete> {
    constructor() {
        super("sf.substreams.v1.InitialSnapshotComplete", [
            { no: 1, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InitialSnapshotComplete>): InitialSnapshotComplete {
        const message = { cursor: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InitialSnapshotComplete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitialSnapshotComplete): InitialSnapshotComplete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cursor */ 1:
                    message.cursor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitialSnapshotComplete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cursor = 1; */
        if (message.cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cursor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.InitialSnapshotComplete
 */
export const InitialSnapshotComplete = new InitialSnapshotComplete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitialSnapshotData$Type extends MessageType<InitialSnapshotData> {
    constructor() {
        super("sf.substreams.v1.InitialSnapshotData", [
            { no: 1, name: "module_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "deltas", kind: "message", T: () => StoreDeltas },
            { no: 4, name: "sent_keys", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "total_keys", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<InitialSnapshotData>): InitialSnapshotData {
        const message = { moduleName: "", sentKeys: "0", totalKeys: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InitialSnapshotData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitialSnapshotData): InitialSnapshotData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string module_name */ 1:
                    message.moduleName = reader.string();
                    break;
                case /* sf.substreams.v1.StoreDeltas deltas */ 2:
                    message.deltas = StoreDeltas.internalBinaryRead(reader, reader.uint32(), options, message.deltas);
                    break;
                case /* uint64 sent_keys */ 4:
                    message.sentKeys = reader.uint64().toString();
                    break;
                case /* uint64 total_keys */ 3:
                    message.totalKeys = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitialSnapshotData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string module_name = 1; */
        if (message.moduleName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.moduleName);
        /* sf.substreams.v1.StoreDeltas deltas = 2; */
        if (message.deltas)
            StoreDeltas.internalBinaryWrite(message.deltas, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 sent_keys = 4; */
        if (message.sentKeys !== "0")
            writer.tag(4, WireType.Varint).uint64(message.sentKeys);
        /* uint64 total_keys = 3; */
        if (message.totalKeys !== "0")
            writer.tag(3, WireType.Varint).uint64(message.totalKeys);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.InitialSnapshotData
 */
export const InitialSnapshotData = new InitialSnapshotData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockScopedData$Type extends MessageType<BlockScopedData> {
    constructor() {
        super("sf.substreams.v1.BlockScopedData", [
            { no: 1, name: "outputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ModuleOutput },
            { no: 3, name: "clock", kind: "message", T: () => Clock },
            { no: 6, name: "step", kind: "enum", T: () => ["sf.substreams.v1.ForkStep", ForkStep] },
            { no: 10, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BlockScopedData>): BlockScopedData {
        const message = { outputs: [], step: 0, cursor: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockScopedData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockScopedData): BlockScopedData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sf.substreams.v1.ModuleOutput outputs */ 1:
                    message.outputs.push(ModuleOutput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sf.substreams.v1.Clock clock */ 3:
                    message.clock = Clock.internalBinaryRead(reader, reader.uint32(), options, message.clock);
                    break;
                case /* sf.substreams.v1.ForkStep step */ 6:
                    message.step = reader.int32();
                    break;
                case /* string cursor */ 10:
                    message.cursor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockScopedData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sf.substreams.v1.ModuleOutput outputs = 1; */
        for (let i = 0; i < message.outputs.length; i++)
            ModuleOutput.internalBinaryWrite(message.outputs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sf.substreams.v1.Clock clock = 3; */
        if (message.clock)
            Clock.internalBinaryWrite(message.clock, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sf.substreams.v1.ForkStep step = 6; */
        if (message.step !== 0)
            writer.tag(6, WireType.Varint).int32(message.step);
        /* string cursor = 10; */
        if (message.cursor !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.cursor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.BlockScopedData
 */
export const BlockScopedData = new BlockScopedData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleOutput$Type extends MessageType<ModuleOutput> {
    constructor() {
        super("sf.substreams.v1.ModuleOutput", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "map_output", kind: "message", oneof: "data", T: () => Any },
            { no: 3, name: "store_deltas", kind: "message", oneof: "data", T: () => StoreDeltas },
            { no: 4, name: "logs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "logs_truncated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ModuleOutput>): ModuleOutput {
        const message = { name: "", data: { oneofKind: undefined }, logs: [], logsTruncated: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleOutput): ModuleOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any map_output */ 2:
                    message.data = {
                        oneofKind: "mapOutput",
                        mapOutput: Any.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).mapOutput)
                    };
                    break;
                case /* sf.substreams.v1.StoreDeltas store_deltas */ 3:
                    message.data = {
                        oneofKind: "storeDeltas",
                        storeDeltas: StoreDeltas.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).storeDeltas)
                    };
                    break;
                case /* repeated string logs */ 4:
                    message.logs.push(reader.string());
                    break;
                case /* bool logs_truncated */ 5:
                    message.logsTruncated = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any map_output = 2; */
        if (message.data.oneofKind === "mapOutput")
            Any.internalBinaryWrite(message.data.mapOutput, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sf.substreams.v1.StoreDeltas store_deltas = 3; */
        if (message.data.oneofKind === "storeDeltas")
            StoreDeltas.internalBinaryWrite(message.data.storeDeltas, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string logs = 4; */
        for (let i = 0; i < message.logs.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.logs[i]);
        /* bool logs_truncated = 5; */
        if (message.logsTruncated !== false)
            writer.tag(5, WireType.Varint).bool(message.logsTruncated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.ModuleOutput
 */
export const ModuleOutput = new ModuleOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModulesProgress$Type extends MessageType<ModulesProgress> {
    constructor() {
        super("sf.substreams.v1.ModulesProgress", [
            { no: 1, name: "modules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ModuleProgress }
        ]);
    }
    create(value?: PartialMessage<ModulesProgress>): ModulesProgress {
        const message = { modules: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModulesProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModulesProgress): ModulesProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sf.substreams.v1.ModuleProgress modules */ 1:
                    message.modules.push(ModuleProgress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModulesProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sf.substreams.v1.ModuleProgress modules = 1; */
        for (let i = 0; i < message.modules.length; i++)
            ModuleProgress.internalBinaryWrite(message.modules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.ModulesProgress
 */
export const ModulesProgress = new ModulesProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleProgress$Type extends MessageType<ModuleProgress> {
    constructor() {
        super("sf.substreams.v1.ModuleProgress", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "processed_ranges", kind: "message", oneof: "type", T: () => ModuleProgress_ProcessedRange },
            { no: 3, name: "initial_state", kind: "message", oneof: "type", T: () => ModuleProgress_InitialState },
            { no: 4, name: "processed_bytes", kind: "message", oneof: "type", T: () => ModuleProgress_ProcessedBytes },
            { no: 5, name: "failed", kind: "message", oneof: "type", T: () => ModuleProgress_Failed }
        ]);
    }
    create(value?: PartialMessage<ModuleProgress>): ModuleProgress {
        const message = { name: "", type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleProgress): ModuleProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* sf.substreams.v1.ModuleProgress.ProcessedRange processed_ranges */ 2:
                    message.type = {
                        oneofKind: "processedRanges",
                        processedRanges: ModuleProgress_ProcessedRange.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).processedRanges)
                    };
                    break;
                case /* sf.substreams.v1.ModuleProgress.InitialState initial_state */ 3:
                    message.type = {
                        oneofKind: "initialState",
                        initialState: ModuleProgress_InitialState.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).initialState)
                    };
                    break;
                case /* sf.substreams.v1.ModuleProgress.ProcessedBytes processed_bytes */ 4:
                    message.type = {
                        oneofKind: "processedBytes",
                        processedBytes: ModuleProgress_ProcessedBytes.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).processedBytes)
                    };
                    break;
                case /* sf.substreams.v1.ModuleProgress.Failed failed */ 5:
                    message.type = {
                        oneofKind: "failed",
                        failed: ModuleProgress_Failed.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).failed)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* sf.substreams.v1.ModuleProgress.ProcessedRange processed_ranges = 2; */
        if (message.type.oneofKind === "processedRanges")
            ModuleProgress_ProcessedRange.internalBinaryWrite(message.type.processedRanges, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sf.substreams.v1.ModuleProgress.InitialState initial_state = 3; */
        if (message.type.oneofKind === "initialState")
            ModuleProgress_InitialState.internalBinaryWrite(message.type.initialState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sf.substreams.v1.ModuleProgress.ProcessedBytes processed_bytes = 4; */
        if (message.type.oneofKind === "processedBytes")
            ModuleProgress_ProcessedBytes.internalBinaryWrite(message.type.processedBytes, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* sf.substreams.v1.ModuleProgress.Failed failed = 5; */
        if (message.type.oneofKind === "failed")
            ModuleProgress_Failed.internalBinaryWrite(message.type.failed, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.ModuleProgress
 */
export const ModuleProgress = new ModuleProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleProgress_ProcessedRange$Type extends MessageType<ModuleProgress_ProcessedRange> {
    constructor() {
        super("sf.substreams.v1.ModuleProgress.ProcessedRange", [
            { no: 1, name: "processed_ranges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BlockRange }
        ]);
    }
    create(value?: PartialMessage<ModuleProgress_ProcessedRange>): ModuleProgress_ProcessedRange {
        const message = { processedRanges: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleProgress_ProcessedRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleProgress_ProcessedRange): ModuleProgress_ProcessedRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sf.substreams.v1.BlockRange processed_ranges */ 1:
                    message.processedRanges.push(BlockRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleProgress_ProcessedRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sf.substreams.v1.BlockRange processed_ranges = 1; */
        for (let i = 0; i < message.processedRanges.length; i++)
            BlockRange.internalBinaryWrite(message.processedRanges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.ModuleProgress.ProcessedRange
 */
export const ModuleProgress_ProcessedRange = new ModuleProgress_ProcessedRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleProgress_InitialState$Type extends MessageType<ModuleProgress_InitialState> {
    constructor() {
        super("sf.substreams.v1.ModuleProgress.InitialState", [
            { no: 2, name: "available_up_to_block", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<ModuleProgress_InitialState>): ModuleProgress_InitialState {
        const message = { availableUpToBlock: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleProgress_InitialState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleProgress_InitialState): ModuleProgress_InitialState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 available_up_to_block */ 2:
                    message.availableUpToBlock = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleProgress_InitialState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 available_up_to_block = 2; */
        if (message.availableUpToBlock !== "0")
            writer.tag(2, WireType.Varint).uint64(message.availableUpToBlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.ModuleProgress.InitialState
 */
export const ModuleProgress_InitialState = new ModuleProgress_InitialState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleProgress_ProcessedBytes$Type extends MessageType<ModuleProgress_ProcessedBytes> {
    constructor() {
        super("sf.substreams.v1.ModuleProgress.ProcessedBytes", [
            { no: 1, name: "total_bytes_read", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "total_bytes_written", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<ModuleProgress_ProcessedBytes>): ModuleProgress_ProcessedBytes {
        const message = { totalBytesRead: "0", totalBytesWritten: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleProgress_ProcessedBytes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleProgress_ProcessedBytes): ModuleProgress_ProcessedBytes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 total_bytes_read */ 1:
                    message.totalBytesRead = reader.uint64().toString();
                    break;
                case /* uint64 total_bytes_written */ 2:
                    message.totalBytesWritten = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleProgress_ProcessedBytes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 total_bytes_read = 1; */
        if (message.totalBytesRead !== "0")
            writer.tag(1, WireType.Varint).uint64(message.totalBytesRead);
        /* uint64 total_bytes_written = 2; */
        if (message.totalBytesWritten !== "0")
            writer.tag(2, WireType.Varint).uint64(message.totalBytesWritten);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.ModuleProgress.ProcessedBytes
 */
export const ModuleProgress_ProcessedBytes = new ModuleProgress_ProcessedBytes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModuleProgress_Failed$Type extends MessageType<ModuleProgress_Failed> {
    constructor() {
        super("sf.substreams.v1.ModuleProgress.Failed", [
            { no: 1, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "logs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "logs_truncated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ModuleProgress_Failed>): ModuleProgress_Failed {
        const message = { reason: "", logs: [], logsTruncated: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModuleProgress_Failed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModuleProgress_Failed): ModuleProgress_Failed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reason */ 1:
                    message.reason = reader.string();
                    break;
                case /* repeated string logs */ 2:
                    message.logs.push(reader.string());
                    break;
                case /* bool logs_truncated */ 3:
                    message.logsTruncated = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModuleProgress_Failed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reason = 1; */
        if (message.reason !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reason);
        /* repeated string logs = 2; */
        for (let i = 0; i < message.logs.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.logs[i]);
        /* bool logs_truncated = 3; */
        if (message.logsTruncated !== false)
            writer.tag(3, WireType.Varint).bool(message.logsTruncated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.ModuleProgress.Failed
 */
export const ModuleProgress_Failed = new ModuleProgress_Failed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockRange$Type extends MessageType<BlockRange> {
    constructor() {
        super("sf.substreams.v1.BlockRange", [
            { no: 1, name: "start_block", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "end_block", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<BlockRange>): BlockRange {
        const message = { startBlock: "0", endBlock: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockRange): BlockRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 start_block */ 1:
                    message.startBlock = reader.uint64().toString();
                    break;
                case /* uint64 end_block */ 2:
                    message.endBlock = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 start_block = 1; */
        if (message.startBlock !== "0")
            writer.tag(1, WireType.Varint).uint64(message.startBlock);
        /* uint64 end_block = 2; */
        if (message.endBlock !== "0")
            writer.tag(2, WireType.Varint).uint64(message.endBlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.BlockRange
 */
export const BlockRange = new BlockRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreDeltas$Type extends MessageType<StoreDeltas> {
    constructor() {
        super("sf.substreams.v1.StoreDeltas", [
            { no: 1, name: "deltas", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StoreDelta }
        ]);
    }
    create(value?: PartialMessage<StoreDeltas>): StoreDeltas {
        const message = { deltas: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StoreDeltas>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreDeltas): StoreDeltas {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sf.substreams.v1.StoreDelta deltas */ 1:
                    message.deltas.push(StoreDelta.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreDeltas, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sf.substreams.v1.StoreDelta deltas = 1; */
        for (let i = 0; i < message.deltas.length; i++)
            StoreDelta.internalBinaryWrite(message.deltas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.StoreDeltas
 */
export const StoreDeltas = new StoreDeltas$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreDelta$Type extends MessageType<StoreDelta> {
    constructor() {
        super("sf.substreams.v1.StoreDelta", [
            { no: 1, name: "operation", kind: "enum", T: () => ["sf.substreams.v1.StoreDelta.Operation", StoreDelta_Operation] },
            { no: 2, name: "ordinal", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "old_value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "new_value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<StoreDelta>): StoreDelta {
        const message = { operation: 0, ordinal: "0", key: "", oldValue: new Uint8Array(0), newValue: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StoreDelta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreDelta): StoreDelta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sf.substreams.v1.StoreDelta.Operation operation */ 1:
                    message.operation = reader.int32();
                    break;
                case /* uint64 ordinal */ 2:
                    message.ordinal = reader.uint64().toString();
                    break;
                case /* string key */ 3:
                    message.key = reader.string();
                    break;
                case /* bytes old_value */ 4:
                    message.oldValue = reader.bytes();
                    break;
                case /* bytes new_value */ 5:
                    message.newValue = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreDelta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sf.substreams.v1.StoreDelta.Operation operation = 1; */
        if (message.operation !== 0)
            writer.tag(1, WireType.Varint).int32(message.operation);
        /* uint64 ordinal = 2; */
        if (message.ordinal !== "0")
            writer.tag(2, WireType.Varint).uint64(message.ordinal);
        /* string key = 3; */
        if (message.key !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.key);
        /* bytes old_value = 4; */
        if (message.oldValue.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.oldValue);
        /* bytes new_value = 5; */
        if (message.newValue.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.newValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.StoreDelta
 */
export const StoreDelta = new StoreDelta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Output$Type extends MessageType<Output> {
    constructor() {
        super("sf.substreams.v1.Output", [
            { no: 1, name: "block_num", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "block_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 10, name: "value", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<Output>): Output {
        const message = { blockNum: "0", blockId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Output>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Output): Output {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 block_num */ 1:
                    message.blockNum = reader.uint64().toString();
                    break;
                case /* string block_id */ 2:
                    message.blockId = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 4:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* google.protobuf.Any value */ 10:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Output, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 block_num = 1; */
        if (message.blockNum !== "0")
            writer.tag(1, WireType.Varint).uint64(message.blockNum);
        /* string block_id = 2; */
        if (message.blockId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.blockId);
        /* google.protobuf.Timestamp timestamp = 4; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any value = 10; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sf.substreams.v1.Output
 */
export const Output = new Output$Type();
/**
 * @generated ServiceType for protobuf service sf.substreams.v1.Stream
 */
export const Stream = new ServiceType("sf.substreams.v1.Stream", [
    { name: "Blocks", serverStreaming: true, options: {}, I: Request, O: Response }
]);
